import java.util.ArrayList;
import java.util.Iterator;

/**
 * the quotient group generated by 2 groups.
 * @author weitao92
 *
 */
public class quotientGroup {
	int order;
	ArrayList<coset> list;
	coset identity;
	element a;
	group H;
	ArrayList<quotientGroup> cyclicgroups;
	
	public quotientGroup(group g, group h)
	{
		a = null;
		this.H = h;
		list = new ArrayList<coset> ();	
		order = g.order / h.order;
		identity = new coset(h, h.list.get(0));
		
		for(element e : g.list)
		{
			coset newOne = new coset(h, e);
			
			if(!list.contains(newOne))
			{
				list.add(newOne);
			}
			
			if(list.size() == order)
			{
				break;
			}
		}
	}
	
	public quotientGroup()
	{
		list = new ArrayList<coset>();
	}
	
	/**
	 * override the toString method.
	 */
	public String toString()
	{
		String result = "{";
		
		for(coset c : list)
		{
			result += c.toString();
			result += " ";
		}
		
		result += "}";
		return result;
	}
	
	/**
	 * determine whether this quotient group is cyclic or not.
	 * @return
	 */
	public boolean cyclic()
	{
		for(coset c : list)
		{
			if(order == c.order(this))
			{
				a = c.left;
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * update the order inside list.
	 */
	public void update()
	{
		if(a == null)
		{
			return; //this quotient group is not cyclic.
		}
		else
		{
			list.removeAll(list);
			list.add(0, identity);
			element temp = new element(a.module1, a.module2, 0, 0);
			for(int i = 1; i < order; i++)
			{
				temp = temp.operation(a, 1);
				coset newOne = new coset(H, temp);
				list.add(i, newOne);
			}
		}
	}
	
	/**
	 * determine whether it's isomorphic to z2*z2 or not.
	 * @return
	 */
	public boolean isomorphic()
	{
		if(order != 4)
		{
			return false;
		}
		else
		{
			for(coset c : list)
			{
				if(c.equals(identity))
				{
					if(c.order(this) != 1)
					{
						return false;
					}
				}
				else
				{
					if(c.order(this) != 2)
					{
						return false;
					}
				}
			}
			
			return true;
		}
	}
	
	/**
	 * implement the equals method.
	 * @param another
	 * @return
	 */
	public boolean equals(Object obj)
	{
		quotientGroup another = (quotientGroup) obj;
		
		if(order != another.order)
		{
			return false;
		}
		else
		{
			for(int i = 0; i < order; i++)
			{
				coset c = list.get(i);
				if(!another.list.get(i).equals(c))
				{
					return false;
				}
			}
			
			return true;
		}
		
	}
	
	/**
	 * generate a list of quotientGroup which is identical with this one but
	 * with different coset orders, basically i just find all coset which has order
	 * of quotientGroup order and i pick one element a from that coset to generate a 
	 * list of a + A/B then add this quotient group to the list.
	 * @return
	 */
	public ArrayList<quotientGroup> generate()
	{
		ArrayList<quotientGroup> groups = new ArrayList<quotientGroup>();
		ArrayList<element> candidateA = new ArrayList<element> ();
		for(coset c : list)
		{
			if(c.order(this) == order)
			{
				Iterator<element> it = c.list.iterator();
				element first = it.next();
				candidateA.add(first);
			}
		}
		
		for(element e : candidateA)
		{
			quotientGroup G = new quotientGroup();
			G.order = this.order;
			G.H = this.H;
	
			G.a = e;
			G.list.add(identity);
			coset c = identity;
			for(int i = 1; i <= order/2; i++)
			{
				c = c.operation(e, 1);
				G.list.add(c);
			}
			
			groups.add(G);
		}
		
		return groups;
	}

}
