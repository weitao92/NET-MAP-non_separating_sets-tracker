import java.util.ArrayList;

/**
 * the quotient group generated by 2 groups.
 * @author weitao92
 *
 */
public class quotientGroup {
	//group father;
	int order;
	ArrayList<coset> list;
	//ArrayList<HashTable<element>> tables;
	coset identity;
	element a;
	group H;
	ArrayList<quotientGroup> cyclicgroups;
	
	public quotientGroup(group g, group h)
	{
		//father = g;
		a = null;
		this.H = h;
		list = new ArrayList<coset> ();	
		//tables = new ArrayList<HashTable<element>>();
		order = g.order / h.order;
		identity = new coset(h, h.list.get(0));
		
		for(element e : g.list)
		{
			coset newOne = new coset(h, e);
			
			if(!list.contains(newOne))
			{
				list.add(newOne);
			}
			
			if(list.size() == order)
			{
				break;
			}
		}
	}
	
	public quotientGroup()
	{
		list = new ArrayList<coset>();
		//tables = new ArrayList<HashTable<element>>();
	}
	
	/**
	 * override the toString method.
	 */
	public String toString()
	{
		String result = "{";
		
		for(coset c : list)
		{
			result += c.toString();
			result += " ";
		}
		
		result += "}";
		return result;
	}
	
	/**
	 * determine whether this quotient group is cyclic or not.
	 * @return
	 */
	public boolean cyclic()
	{
		for(coset c : list)
		{
			if(order == c.order(this))
			{
				a = c.left;
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * update the order inside list.
	 */
	public void update()
	{
		if(a == null)
		{
			return; //this quotient group is not cyclic.
		}
		else
		{
			list.removeAll(list);
			list.add(0, identity);
			/**
			HashTable<element> first = new HashTable<element> ();
			for(element elem : identity.list)
			{
				first.add(elem);
			}
			tables.add(0, first);
			**/
			element temp = new element(a.module1, a.module2, 0, 0);
			for(int i = 1; i < order; i++)
			{
				temp = temp.operation(a, 1);
				coset newOne = new coset(H, temp);
				/**
				HashTable<element> table = new HashTable<element>();
				for(element e : newOne.list)
				{
					table.add(e);
				}
				tables.add(i, table);
				**/
				list.add(i, newOne);
			}
		}
	}
	
	/**
	 * determine whether it's isomorphic to z2*z2 or not.
	 * @return
	 */
	public boolean isomorphic()
	{
		if(order != 4)
		{
			return false;
		}
		else
		{
			for(coset c : list)
			{
				if(c.equals(identity))
				{
					if(c.order(this) != 1)
					{
						return false;
					}
				}
				else
				{
					if(c.order(this) != 2)
					{
						return false;
					}
				}
			}
			
			return true;
		}
	}
	
	/**
	 * implement the equals method.
	 * @param another
	 * @return
	 */
	public boolean equals(Object obj)
	{
		quotientGroup another = (quotientGroup) obj;
		
		if(order != another.order)
		{
			return false;
		}
		else
		{
			for(int i = 0; i < order; i++)
			{
				coset c = list.get(i);
				if(!another.list.get(i).equals(c))
				{
					return false;
				}
			}
			
			return true;
		}
		
	}
	
	public void sortCosets()
	{
		for(coset c : list)
		{
			c.sortList();
		}
	}
	
	/**
	 * generate a list of quotientGroup which is identical with this one but
	 * with different coset orders, basically i just find all coset which has order
	 * of quotientGroup order and i pick one element a from that coset to generate a 
	 * list of a + A/B then add this quotient group to the list.
	 * @return
	 */
	public ArrayList<quotientGroup> generate()
	{
		ArrayList<quotientGroup> groups = new ArrayList<quotientGroup>();
		this.sortCosets();
		//groups.add(this);
		ArrayList<element> candidateA = new ArrayList<element> ();
		for(coset c : list)
		{
			if(c.order(this) == order)
			{
				candidateA.add(c.list.get(0));
			}
		}
		
		for(element e : candidateA)
		{
			quotientGroup G = new quotientGroup();
			//G.father = null;
			G.order = this.order;
			//G.H = this.H;
			//G.identity = this.identity;
			
			/**
			HashTable<element> first = new HashTable<element> ();
			for(element elem : G.identity.list)
			{
				first.add(elem);
			}
			G.tables.add(0, first);
			**/
			
			G.a = e;
			G.list.add(identity);
			coset c = identity;
			for(int i = 1; i <= order/2; i++)
			{
				c = c.operation(e, 1);
				G.list.add(c);
				
				/**
				HashTable<element> table = new HashTable<element>();
				for(element elem : c.list)
				{
					table.add(elem);
				}
				G.tables.add(i, table);
				**/
			}
			//G.update();
			G.sortCosets();
			
			groups.add(G);
		}
		
		return groups;
	}

}
