import java.util.ArrayList;
//import java.util.Collections;
import java.util.HashSet;

/**
 * coset class generated by a subgroup and one element.
 * @author weitao92
 *
 */
public class coset {
	
	int order;
	//ArrayList<element> list;
	HashSet<element> list;
	element left;
	
	/**
	 * generate a coset from a group and one element.
	 * @param g
	 * @param e
	 */
	public coset(group g, element e)
	{
		left = e;
		order = g.order;
		//list = new ArrayList<element> ();
		list = new HashSet<element>();
		
		for(element elem : g.list)
		{
			list.add(elem.operation(e, 1));
		}
	}
	
	public coset()
	{
		//list = new ArrayList<element>();
		list = new HashSet<element>();
	}
	
	public coset operation(element e, int i)
	{
		coset c = new coset();
		c.order = this.order;
		for(element elem : list)
		{
			element temp = elem.operation(e, i);
			c.list.add(temp);
		}
		
		return c;
	}
	
	/**
	 * compute the order of current coset in g.
	 * @param g
	 * @return
	 */
	public int order(quotientGroup g)
	{
		
		int order = 2;
		
		if(g.identity.list.contains(left))
		{
			return 1;
		}
		
		element temp = left;
		
		while(true)
		{
			//element temp = left;
			temp = temp.operation(left, 1);
			
			if(g.identity.list.contains(temp))
			{
				//System.out.println(temp);
				break;
			}
			else
			{
				order++;
			}
		}
		
		return order;
		
		//return left.order();
	}
	
	
	
	/**
	 * override the toString method.
	 */
	public String toString()
	{
		String result = "[";
		
		for(element e : list)
		{
			result += e.toString();
			result += " ";
		}
		
		result += "]";
		return result;
	}
	
	/**
	 * implement the equals method.
	 * @param another
	 * @return
	 */
	public boolean equals(Object obj)
	{
		coset another = (coset) obj;
		
		if(order != another.order)
		{
			return false;
		}
		else
		{
			for(element e : list)
			{
				if(!another.list.contains(e))
				{
					return false;
				}
			}
			
			return true;
		}		
	}
	
	/**
	 * run the binary search on the element list.
	 * @param target
	 * @return
	 */
	public boolean contains(element target)
	{
		/**
		int start = 0;
		int end = list.size() - 1;
		boolean found = false;
		
		while(!found && start <= end)
		{
			int mid = (start + end) / 2;
			int result = list.get(mid).compareTo(target);
			if(result == 0)
			{
				found = true;
			}
			else if(result == -1)
			{
				start = mid + 1;
			}
			else
			{
				end = mid - 1;
			}		
		}
		
		return found;
		**/
		return list.contains(target);
	}
	
	/**
	 * Sort the entire list based on element's compareTo method.
	 */
	public void sortList()
	{
		//doInsertionSort(list);
		//Collections.sort(list);
	}
	
	public static void doInsertionSort(ArrayList<element> input){
        
        element temp;
        for (int i = 1; i < input.size(); i++) {
            for(int j = i ; j > 0 ; j--){
                if(input.get(j).compareTo(input.get(j-1)) == 0){
                    temp = input.get(j);
                    input.set(j, input.get(j-1));
                    input.set(j-1, temp);
                }
            }
        }
    }
}
